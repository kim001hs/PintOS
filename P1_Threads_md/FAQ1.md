
---

## 📝 자주 묻는 질문 (FAQ) 해석

### 💻 코드를 얼마나 작성해야 하나요?

Git diff --stat으로 생성된 **참고 솔루션** 요약은 다음과 같습니다. 마지막 행은 삽입 및 삭제된 총 라인 수를 나타냅니다. 변경된 라인은 삽입 및 삭제 모두로 계산됩니다.

참고 솔루션은 하나의 가능한 해답일 뿐입니다. 다른 많은 솔루션도 가능하며, 그중 다수는 참고 솔루션과 크게 다를 수 있습니다. 일부 훌륭한 솔루션은 참고 솔루션에서 수정된 모든 파일을 수정하지 않을 수도 있고, 참고 솔루션에서는 수정되지 않은 파일을 수정할 수도 있습니다.

| 파일 | 변경 내역 (삽입/삭제) |
| :--- | :--- |
| devices/timer.c | 29 +++++++++++++++++++++++++++++ |
| include/threads/fixed-point.h | 10 ++++++++++ |
| include/threads/synch.h | 4 ++++ |
| include/threads/thread.h | 21 +++++++++++++++++++++ |
| threads/synch.c | 143 +++++++++++++++++++++++++++++++++++++++++++- |
| threads/thread.c | 135 ++++++++++++++++++++++++++++++++++++++++---- |
| **총계** | **6개 파일 변경, 330줄 삽입, 12줄 삭제** |

`fixed-point.h`는 참고 솔루션에 의해 새로 추가된 파일이다.

---

### ⚙️ 새 소스 파일을 추가할 때 **Makefiles**는 어떻게 업데이트하나요?

**.c 파일을 추가**하려면, 각 하위 디렉토리의 **`targets.mk`** 파일을 편집하십시오. 새 파일을 변수 **`dir_SRC`**에 추가하십시오. 여기서 `dir`은 `targets.mk`가 위치한 디렉토리 이름입니다. 그 후 `make`를 실행하십시오. 새 파일이 컴파일되지 않으면, **`make clean`**을 실행한 후 다시 시도하십시오. **새로운 .h 파일은 Makefiles 편집을 요구하지 않습니다.**

### ⚠️ warning: no previous prototype for func 경고는 무엇을 의미하나요?

이것은 **함수 프로토타입** 없이 **비정적(non-static) 함수**를 정의했음을 의미합니다. 비정적 함수는 다른 `.c` 파일에서 사용하기 위한 것이므로, 안전을 위해 정의 전에 포함되는 **헤더 파일**에 프로토타입이 있어야 합니다.

이 문제를 해결하려면,
1.  **포함하는 헤더 파일에 프로토타입을 추가**하거나,
2.  해당 함수가 실제로 다른 `.c` 파일에서 사용되지 않는다면 **`static`으로 만드십시오.**

### ⏱️ 타이머 인터럽트 간격은 얼마인가요?

타이머 인터럽트는 초당 **`TIMER_FREQ`**만큼 발생합니다. 이 값은 **`devices/timer.h`**를 편집하여 조정할 수 있습니다. **기본값은 100Hz**입니다. 이 값을 변경하는 것은 많은 테스트 실패를 유발할 가능성이 높으므로 권장하지 않습니다.

### ⏲️ 타임 슬라이스의 길이는 얼마인가요?

타임 슬라이스당 **`TIME_SLICE`** 틱이 있습니다. 이 매크로는 **`threads/thread.c`**에 선언되어 있습니다. **기본값은 4틱**입니다. 이 값을 변경하는 것은 많은 테스트 실패를 유발할 가능성이 높으므로 권장하지 않습니다.

### 🧪 테스트는 어떻게 실행하나요?

**"Testing"** 문서를 참조하십시오.

### ❌ `pass()`에서 테스트 실패가 발생하는 이유는 무엇인가요?

다음과 유사한 **백트레이스(backtrace) 출력**을 보고 있을 수 있습니다.

> 0x8004208810: debug_panic (lib/kernel/debug.c:32)
> 0x800420a99f: pass (tests/threads/tests.c:93)
> ...

이것은 백트레이스 프로그램의 혼란스러운 출력일 뿐입니다. 실제로 `pass()`가 `debug_panic()`을 호출했다는 의미는 아닙니다. 사실은 `fail()`이 `debug_panic()`을 호출했습니다(`PANIC()` 매크로를 통해). **GCC**는 `debug_panic()`이 `NO_RETURN`으로 선언되어 반환하지 않는다는 것을 알기 때문에, `debug_panic()`이 반환할 때 제어를 가져올 코드를 `fail()`에 포함하지 않습니다.

이로 인해 스택의 반환 주소가 **메모리상에서 `fail()` 함수 바로 다음에 오는 함수**의 시작 부분처럼 보이게 되며, 이 경우에는 우연히 **`pass()`**가 되는 것입니다. 자세한 정보는 **"Backtraces"** 문서를 참조하십시오.

### 🔁 `schedule()` 이후 새 스레드에서 인터럽트가 어떻게 다시 활성화되나요?

`schedule()`로 들어가는 모든 경로는 인터럽트를 비활성화합니다. 인터럽트는 결국 다음에 스케줄링되는 스레드에 의해 다시 활성화됩니다. 가능한 경우를 고려하면 다음과 같습니다.

* 새 스레드는 `schedule()`에 의해 호출되는 **`switch_thread()`** 내에서 실행되거나 (아래 참조),
* `schedule()`이 호출되는 곳:
    * **`thread_exit()`**: 해당 스레드로 다시 전환되지 않으므로 흥미롭지 않습니다.
    * **`thread_yield()`**: `schedule()`에서 복귀 시 즉시 인터럽트 수준을 복원합니다.
    * **`thread_block()`**: **`sema_down()`**을 포함하여 여러 곳에서 호출되며, `schedule()`에서 복귀 시 즉시 인터럽트 수준을 복원합니다.
    * **`idle()`**: 명시적인 어셈블리 **`STI`** 명령어로 인터럽트를 활성화합니다.
    * **`devices/intq.c`**의 **`wait()`**: 호출자가 인터럽트 재활성화 책임이 있습니다.

**새로 생성된 스레드**가 처음 실행될 때의 **특별한 경우**가 있습니다. 이러한 스레드는 **`kernel_thread()`**에서 첫 번째 작업으로 **`intr_enable()`**을 호출합니다. 이는 첫 번째를 제외한 모든 커널 스레드의 호출 스택 가장 아래에 있습니다.

### ⏳ 타이머 값이 오버플로우 되는 것을 고려해야 하나요?

타이머 값이 오버플로우 될 가능성에 대해 **걱정할 필요는 없습니다.** 타이머 값은 **부호 있는 64비트 숫자**로 표현되며, 초당 100틱 기준으로 **거의 2,924,712,087년** 동안 유효합니다.

### 🌟 우선순위 스케줄링은 기아(starvation)를 유발하지 않나요?

**네**, 엄격한 우선순위 스케줄링은 더 높은 우선순위의 스레드가 실행 가능하면 낮은 우선순위의 스레드가 실행되지 않기 때문에 **기아 상태를 유발**할 수 있습니다. **고급 스케줄러**는 동적으로 스레드 우선순위를 변경하는 메커니즘을 도입합니다.

엄격한 우선순위 스케줄링은 **실시간 시스템**에서 가치가 있는데, 프로그래머에게 어떤 작업이 처리 시간을 얻을지 더 많은 제어를 제공하기 때문입니다. 높은 우선순위는 일반적으로 **시간에 민감한 작업**을 위해 예약됩니다. 이는 "공평"하지는 않지만, 범용 운영 체제에는 적용되지 않는 다른 고려 사항을 다루고 있습니다.

### 🔓 락(lock)이 해제된 후 어떤 스레드가 실행되어야 하나요?

락이 해제되면, **해당 락을 기다리는 가장 높은 우선순위의 스레드**가 차단 해제되어 **준비된 스레드(ready threads) 목록**에 추가되어야 합니다. 그런 다음 스케줄러는 **준비 목록에서 가장 높은 우선순위의 스레드**를 실행해야 합니다.

### 🏃 가장 높은 우선순위의 스레드가 양보(yield)하면 계속 실행되나요?

**예**. 가장 높은 우선순위의 스레드가 **단 하나**라면, **`thread_yield()`를 호출하더라도** 차단되거나 완료될 때까지 계속 실행됩니다. **여러 스레드가 동일한 최고 우선순위**를 가지고 있다면, **`thread_yield()`**는 **"라운드 로빈"** 순서로 스레드 간에 전환해야 합니다.

### 🎁 기부(donating)하는 스레드의 우선순위는 어떻게 되나요?

**우선순위 기부**는 **기부를 받는 스레드(donee thread)의 우선순위만 변경**합니다. **기부하는 스레드(donor thread)의 우선순위는 변경되지 않습니다.**

또한, 우선순위 기부는 **누적되지 않습니다**: 스레드 A(우선순위 5)가 스레드 B(우선순위 3)에게 기부하면, B의 새 우선순위는 8이 아닌 **5**가 됩니다.

### 큐에 있는 스레드의 우선순위가 바뀔 수 있나요?

* **준비 큐(ready queue)에 있는 동안 우선순위가 바뀔 수 있나요?**
    **예**. 락을 소유한 준비 상태의 낮은 우선순위 스레드 L을 고려하십시오. 높은 우선순위 스레드 H가 락을 획득하려고 시도하고 차단되면서, 준비 상태의 스레드 L에게 자신의 우선순위를 기부할 수 있습니다.

* **차단된(blocked) 동안 우선순위가 바뀔 수 있나요?**
    **예**. 락 L을 획득한 스레드가 어떤 이유로든 차단되어 있는 동안, 더 높은 우선순위의 스레드가 L을 획득하려고 시도하면 **우선순위 기부**를 통해 그 우선순위가 **증가**할 수 있습니다. 이 경우는 `priority-donate-sema` 테스트에서 확인됩니다.

###  preemptive

**준비 목록에 추가된 스레드가 프로세서를 선점할 수 있나요?**
**예**. 준비 목록에 추가된 스레드가 현재 실행 중인 스레드보다 **더 높은 우선순위**를 갖는 경우, 올바른 동작은 프로세서를 **즉시 양보(yield)하는 것**입니다. 다음 타이머 인터럽트를 기다리는 것은 허용되지 않습니다. 가장 높은 우선순위의 스레드는 **실행 가능한 상태가 되자마자** 현재 실행 중인 스레드를 **선점**하고 실행되어야 합니다.

### `thread_set_priority()`는 기부를 받는 스레드에 어떻게 영향을 미치나요?

이 함수는 스레드의 **기본 우선순위(base priority)**를 설정합니다. 스레드의 **유효 우선순위(effective priority)**는 **새로 설정된 우선순위**와 **가장 높은 기부된 우선순위** 중 더 높은 값이 됩니다. 기부된 우선순위가 해제되면, 스레드의 우선순위는 이 함수 호출을 통해 설정된 우선순위로 돌아갑니다. 이 동작은 `priority-donate-lower` 테스트에서 확인됩니다.

### 🐛 출력에서 테스트 이름이 두 번 나타나서 테스트가 실패합니다.

출력에서 다음과 같이 일부 테스트 이름이 **두 번** 나타나는 것을 보고 있다면:

> (alarm-priority) begin
> (alarm-priority) (alarm-priority) Thread priority 30 woke up.
> Thread priority 29 woke up.
> (alarm-priority) Thread priority 28 woke up.

이는 **두 스레드로부터의 출력이 섞이고 있기 때문**에 발생합니다. 즉, 한 스레드가 `(alarm-priority) Thread priority 29 woke up.\n`를 출력하고 있고, 다른 스레드가 `(alarm-priority) Thread priority 30 woke up.\n`를 출력하고 있는데, 첫 번째 스레드가 출력 중간에 두 번째 스레드에 의해 **선점**되고 있는 것입니다.

이 문제는 **우선순위 스케줄러의 버그**를 나타냅니다. 우선순위 30인 스레드가 할 일이 있는 동안에는 우선순위 29인 스레드가 실행될 수 없어야 하기 때문입니다. 일반적으로 Pintos 커널의 `printf()` 함수 구현은 `printf` 호출 기간 동안 **콘솔 락(console lock)**을 획득하고 완료 후 해제하여 이러한 출력이 섞이는 것을 방지하려고 시도합니다. 그러나 테스트 이름 (예: `(alarm-priority)`)과 그 뒤의 메시지는 **두 번의 `printf` 호출**을 사용하여 출력되므로, 콘솔 락이 두 번 획득 및 해제되어 문제가 발생합니다.

### 🎁 우선순위 기부는 고급 스케줄러와 어떻게 상호 작용하나요?

**상호 작용할 필요가 없습니다.** 저희는 우선순위 기부와 고급 스케줄러를 동시에 테스트하지 않을 것입니다.

### 🔢 64개의 큐 대신 하나의 큐를 사용할 수 있나요?

**예**. 일반적으로 구현은 그 **동작이 동일하다면** 설명과 다를 수 있습니다.

### ❓ 일부 스케줄러 테스트가 실패하는데 이유를 모르겠습니다. 도와주세요!

구현이 일부 고급 스케줄러 테스트에서 알 수 없는 이유로 실패하는 경우, 다음을 시도하십시오.

* **실패하는 테스트의 소스 파일**을 읽어서 무엇이 진행되고 있는지 확실히 이해하십시오. 각 파일 상단에는 목적과 예상 결과를 설명하는 주석이 있습니다.
* **고정 소수점(fixed-point) 산술 루틴**과 스케줄러 루틴에서의 사용을 **다시 확인**하십시오.
* **타이머 인터럽트에서 구현이 얼마나 많은 작업을 수행하는지** 고려하십시오. 타이머 인터럽트 핸들러가 너무 오래 걸리면, 타이머 인터럽트에 의해 선점된 스레드로부터 대부분의 타이머 틱을 빼앗아 갈 것입니다. 제어가 해당 스레드로 돌아올 때, 다음 타이머 인터럽트가 도착하기 전에 많은 작업을 수행할 기회를 얻지 못할 것입니다. 그 결과 해당 스레드는 실제로 사용한 것보다 훨씬 많은 CPU 시간을 사용한 것으로 **책임(blamed)을 지게** 됩니다. 이는 **인터럽트된 스레드의 최근 CPU 사용량(recent CPU count)을 증가**시켜 **우선순위를 낮추게** 됩니다. 이는 스케줄링 결정을 변경할 수 있습니다. 또한 **로드 평균(load average)**을 높이게 됩니다.

---
