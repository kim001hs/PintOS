## 🚀 고급 스케줄러 (4.4BSD MLFQS) 구현 개요 해석

 **4.4BSD 스케줄러**와 유사한 **다단계 피드백 큐 스케줄러(MLFQS)**를 구현하는 과제

이 스케줄러는 **우선순위 기반**으로 스레드를 선택하지만, **우선순위 기부(priority donation)는 수행하지 않습니다.** 따라서 우선순위 기부를 제외한 우선순위 스케줄러를 먼저 구현하는 것이 권장됩니다.

---

### 1. 스케줄러 활성화 및 제어

* **기본값:** 기본적으로는 **우선순위 스케줄러**가 활성화됩니다.
* **MLFQS 활성화:** Pintos 시작 시 **`-mlfqs`** 커널 옵션을 사용하여 4.4BSD 스케줄러를 선택할 수 있습니다. 이 옵션이 전달되면 **`thread_mlfqs`** 변수(`threads/thread.h`에 선언)가 참(`true`)으로 설정됩니다.
* **우선순위 제어:** MLFQS가 활성화되면 스레드는 더 이상 자신의 우선순위를 직접 제어할 수 없습니다.
    * `thread_create()`의 우선순위 인수는 **무시**됩니다.
    * `thread_set_priority()` 호출은 **무시**됩니다.
    * `thread_get_priority()`는 **스케줄러가 설정한 현재 우선순위**를 반환해야 합니다.

---

### 2. 4.4BSD 스케줄러의 목표 및 동작


* **목표:** **I/O 중심** 스레드(빠른 응답 시간 필요)와 **계산 중심** 스레드(많은 CPU 시간 필요)의 요구 사항 균형을 맞춥니다.
* **구조:** 우선순위가 다른 여러 개의 **준비 상태 스레드 큐**를 유지하는 **다단계 피드백 큐 스케줄러** 유형입니다.
    * **선택:** 스케줄러는 **가장 높은 우선순위의 비어 있지 않은 큐**에서 스레드를 선택합니다.
    * **라운드 로빈:** 최고 우선순위 큐에 여러 스레드가 있을 경우, **"라운드 로빈(round robin)"** 순서로 실행됩니다.
* **업데이트 시점:** 스케줄러 관련 데이터 업데이트(틱 수에 따른)는 일반 커널 스레드가 실행되기 **전에** 발생해야 합니다.
* **특징:** 우선순위 기부는 포함하지 않습니다.

---

### 3. Niceness (나이스 값)

**`nice`** 값은 스레드가 다른 스레드에게 얼마나 **"친절해야"** 하는지를 결정하는 정수 값입니다.

* **범위:** **-20(최소)부터 20(최대)**까지입니다.
* **효과:**
    * `nice`가 **0**이면 우선순위에 영향을 주지 않습니다.
    * `nice`가 **양수**이면 우선순위가 낮아지고 CPU 시간을 다른 스레드에게 양보합니다.
    * `nice`가 **음수**이면 우선순위가 높아지고 다른 스레드의 CPU 시간을 가져오는 경향이 있습니다.
* **초기값:** 초기 스레드는 0으로 시작하며, 다른 스레드는 부모 스레드로부터 `nice` 값을 **상속**받습니다.
* **필수 구현 함수:**
    * `int thread_get_nice (void)`: 현재 스레드의 `nice` 값을 반환합니다.
    * `int thread_set_nice (int nice)`: 현재 스레드의 `nice` 값을 설정하고, 새 값에 따라 **우선순위를 재계산**합니다. 현재 스레드가 최고 우선순위가 아니라면 **즉시 양보**합니다.

---

### 4. 우선순위 계산

스케줄러는 **0(최저)부터 63(최고)**까지 64개의 우선순위와 64개의 준비 큐를 가집니다.

* **계산 시점:** 스레드 초기화 시, 그리고 이후 **4번의 클럭 틱마다** 모든 스레드에 대해 **우선순위를 재계산**합니다.
* **계산 공식:**
    $$\text{priority} = \text{PRI\_MAX} - (\text{recent\_cpu} / 4) - (\text{nice} \times 2)$$
    * 결과는 **가장 가까운 정수로 내림(truncate)**해야 합니다.
    * 계산된 우선순위는 항상 유효 범위($\text{PRI\_MIN}$ ~ $\text{PRI\_MAX}$) 내에 있도록 **조정**해야 합니다.
* **의미:** 이 공식은 최근에 CPU 시간을 많이 받은 스레드에게 더 낮은 우선순위를 부여하여, **기아(starvation) 상태**를 방지하는 핵심 역할을 합니다.

---

### 5. $\text{recent\_cpu}$ 계산

**$\text{recent\_cpu}$**는 스레드가 **"최근에"** 사용한 CPU 시간을 측정하며, **지수 가중 이동 평균(Exponentially Weighted Moving Average)**을 사용합니다.

* **초기값:** 처음 생성된 스레드는 0, 다른 새 스레드는 **부모 스레드의 값**을 상속받습니다.
* **매 틱 업데이트:** **타이머 인터럽트가 발생할 때마다**, **현재 실행 중인 스레드**($\text{idle}$ 스레드 제외)의 $\text{recent\_cpu}$는 **1씩 증가**합니다.
* **초당 업데이트:** **1초에 한 번**($\text{timer\_ticks}() \% \text{TIMER\_FREQ} == 0$ 일 때), 실행 중, 준비 상태, 차단된 **모든 스레드**의 $\text{recent\_cpu}$ 값이 다음 공식으로 재계산됩니다.
    $$\text{recent\_cpu} = \frac{2 \times \text{load\_avg}}{2 \times \text{load\_avg} + 1} \times \text{recent\_cpu} + \text{nice}$$
    * **특징:** $\text{load\_avg}$에 반비례하여 $\text{recent\_cpu}$의 감소율이 결정되므로, 경쟁하는 스레드 수에 따라 CPU 시간 추정치가 조정됩니다.
    * **주의:** 음수 $\text{nice}$ 값으로 인해 $\text{recent\_cpu}$가 음수가 될 수 있으며, **0으로 고정해서는 안 됩니다.** 또한, 오버플로우를 방지하기 위해 계산 순서에 유의하고 64비트 연산을 고려해야 합니다.
* **필수 구현 함수:**
    * `int thread_get_recent_cpu (void)`: 현재 스레드의 $\text{recent\_cpu}$ 값에 **100을 곱한 값**을 **가장 가까운 정수로 반올림**하여 반환합니다.

---

### 6. $\text{load\_avg}$ 계산

**$\text{load\_avg}$**(시스템 로드 평균)는 지난 1분 동안 실행 준비가 된 스레드의 평균 수를 추정하는 **시스템 전반적인** 값입니다.

* **초기값:** 시스템 부팅 시 **0**으로 초기화됩니다.
* **초당 업데이트:** **1초에 한 번**($\text{timer\_ticks}() \% \text{TIMER\_FREQ} == 0$ 일 때), 다음 공식에 따라 업데이트됩니다.
    $$\text{load\_avg} = \frac{59}{60} \times \text{load\_avg} + \frac{1}{60} \times \text{ready\_threads}$$
    * **$\text{ready\_threads}$:** 업데이트 시점에 **실행 중**이거나 **실행 준비 상태**인 스레드의 수입니다. ($\text{idle}$ 스레드는 제외).
* **필수 구현 함수:**
    * `int thread_get_load_avg (void)`: 현재 시스템 $\text{load\_avg}$에 **100을 곱한 값**을 **가장 가까운 정수로 반올림**하여 반환합니다.

---

### 7. 📏 고정 소수점 실수 연산 (Fixed-Point Real Arithmetic)

Pintos 커널은 부동 소수점(floating-point)을 지원하지 않으므로, $\text{recent\_cpu}$ 및 $\text{load\_avg}$와 같은 **실수(real numbers) 계산**은 정수를 사용하여 시뮬레이션해야 합니다.

* **표현 형식:** 부호 있는 32비트 정수에서 **가장 낮은 14비트**를 **소수부**로 사용합니다. 이를 **17.14 고정 소수점** 표현이라고 합니다.
    * $\text{F}$ 값: $2^{14}$를 사용합니다.
    * 정수 $x$는 실수 $x / 2^{14}$를 나타냅니다.
* **변환 및 연산 요약:**
    | 연산 | C 코드 |
    | :--- | :--- |
    | 정수 $n$을 고정 소수점으로 변환 | $\text{n} \times \text{F}$ |
    | 고정 소수점 $x$를 정수로 변환 (0으로 반올림) | $x / \text{F}$ |
    | 고정 소수점 $x$를 정수로 변환 (가장 가까운 정수로 반올림) | $(x + \text{F} / 2) / \text{F}$ (양수) 또는 $(x - \text{F} / 2) / \text{F}$ (음수) |
    | 고정 소수점 $x$와 $y$의 곱 | $\text{((int64\_t)} x) \times y / \text{F}$ |
    | 고정 소수점 $x$와 $y$의 나눗셈 | $\text{((int64\_t)} x) \times \text{F} / y$ |

이러한 고정 소수점 연산을 정확히 구현하는 것이 고급 스케줄러 구현의 핵심적인 선행 작업이 됩니다.