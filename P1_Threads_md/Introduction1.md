**Pintos Project1: Threads**

---

## 💻 Project 1: Threads (스레드)

이 과제에서는 **최소한의 기능만 갖춘 스레드 시스템**을 제공합니다. 여러분의 임무는 이 시스템의 기능을 확장하여 **동기화 문제**에 대한 더 나은 이해를 얻는 것입니다. 주로 **`threads` 디렉토리**에서 작업하며, 부수적으로 **`devices` 디렉토리**에서도 일부 작업을 수행하게 됩니다. 컴파일은 `threads` 디렉토리에서 이루어져야 합니다. 이 프로젝트 설명을 읽기 전에 **동기화(Synchronization)** 관련 자료를 적어도 한 번 훑어보시기 바랍니다.

---

## 📚 배경 지식: 스레드의 이해

첫 번째 단계는 초기 스레드 시스템 코드를 읽고 **이해**하는 것입니다. Pintos는 이미 **스레드 생성 및 완료**, 스레드 간 전환을 위한 **간단한 스케줄러**, 그리고 **동기화 기본 요소** (세마포어, 락, 조건 변수, 최적화 장벽)를 구현하고 있습니다.

이 코드 중 일부는 다소 **난해하게** 보일 수 있습니다. 아직 기본 시스템을 컴파일하고 실행해 보지 않았다면, 소개 자료에 설명된 대로 지금 바로 실행해야 합니다. 소스 코드의 일부를 읽으면서 어떤 일이 일어나고 있는지 확인할 수 있습니다. 원한다면 거의 모든 곳에 **`printf()`** 호출을 추가하고, 다시 컴파일하여 실행해 보면서 어떤 일이 어떤 순서로 발생하는지 볼 수 있습니다. 또한, 커널을 **디버거**에서 실행하고 흥미로운 지점에 중단점(breakpoint)을 설정하거나, 코드를 단계별로 실행하고 데이터를 검사할 수도 있습니다.

스레드가 생성될 때, 스케줄링될 **새로운 컨텍스트**가 생성됩니다. 이 컨텍스트에서 실행될 함수를 **`thread_create()`의 인수로 제공**합니다. 스레드가 처음 스케줄링되어 실행될 때, 해당 함수의 시작 부분부터 시작하여 그 컨텍스트에서 실행됩니다. 함수가 반환되면 스레드는 종료됩니다. 따라서 각 스레드는 Pintos 내에서 실행되는 **작은 프로그램**처럼 작동하며, `thread_create()`에 전달된 함수가 **`main()`**처럼 작동합니다.

**특정 시점에는 정확히 하나의 스레드만 실행**되고 나머지는 (있다면) 비활성 상태가 됩니다. **스케줄러**가 다음에 실행할 스레드를 결정합니다. (어떤 시점에도 실행 준비가 된 스레드가 없다면, **`idle()`**에 구현된 **특별한 `idle` 스레드**가 실행됩니다.) **동기화 기본 요소**는 한 스레드가 다른 스레드가 무언가를 하기를 기다려야 할 때 **컨텍스트 전환**을 강제할 수 있습니다.

**컨텍스트 전환**의 메커니즘은 **`threads/thread.c`**의 **`thread_launch()`**에 있습니다 (이 코드를 이해할 필요는 없습니다). 이 함수는 현재 실행 중인 스레드의 상태를 저장하고, 전환할 스레드의 상태를 복원합니다.

**GDB 디버거**를 사용하여 컨텍스트 전환이 어떻게 발생하는지 **천천히 추적**해 보십시오. 시작하려면 **`schedule()`**에 중단점을 설정한 다음, 거기서부터 단계별로 실행할 수 있습니다. 각 스레드의 주소와 상태, 그리고 각 스레드의 호출 스택에 어떤 프로시저가 있는지 계속 추적하십시오. 한 스레드가 **`do_iret()`**에서 **`iret`** 명령을 실행할 때, 다른 스레드가 실행되기 시작하는 것을 알 수 있을 것입니다.

> ⚠️ **경고:** Pintos에서 각 스레드에는 **4kB 미만의 작고 고정된 크기의 실행 스택**이 할당됩니다. 커널이 스택 오버플로우를 감지하려고 시도하지만 완벽하게 수행할 수는 없습니다. 예를 들어 `int buf[1000];`와 같이 **큰 데이터 구조를 비정적 지역 변수로 선언**하면, **이상한 문제(예: 정체불명의 커널 패닉)**를 일으킬 수 있습니다. 스택 할당의 대안으로는 **페이지 할당자(page allocator)**와 **블록 할당자(block allocator)**가 있습니다.

---

## 📂 소스 파일

다음은 **`threads`** 및 **`include/threads`** 디렉토리의 파일에 대한 간략한 개요입니다. 이 코드 대부분을 수정할 필요는 없지만, 이 개요가 어떤 코드를 봐야 할지 파악하는 데 도움이 되기를 바랍니다.

### `threads` 코드

* **`loader.S`, `loader.h`**: **커널 로더**입니다. PC BIOS가 메모리에 로드하는 512바이트의 코드 및 데이터로 어셈블되며, 이는 다시 디스크에서 커널을 찾아 메모리에 로드하고 `start.S`의 `bootstrap()`으로 점프합니다. 이 코드를 보거나 수정할 필요는 없을 것입니다. `start.S`는 메모리 보호를 위한 기본 설정을 수행하고 64비트 롱 모드(long mode)로 점프합니다. 이 코드는 로더와 달리 실제로 커널의 일부입니다.
* **`kernel.lds.S`**: 커널을 링크하는 데 사용되는 **링커 스크립트**입니다. 커널의 로드 주소를 설정하고 `start.S`가 커널 이미지의 시작 부분 근처에 배치되도록 합니다. 이 코드를 보거나 수정할 필요는 없지만, 궁금할 경우를 대비하여 여기에 있습니다.
* **`init.c`, `init.h`**: 커널의 **메인 프로그램인 `main()`**을 포함한 **커널 초기화** 코드입니다. 최소한 `main()`을 살펴보고 무엇이 초기화되는지 확인해야 합니다. 여기에 자신의 초기화 코드를 추가할 수도 있습니다.
* **`thread.c`, `thread.h`**: **기본 스레드 지원** 코드입니다. 여러분의 작업 대부분이 이 파일들에서 이루어질 것입니다. `thread.h`는 **`struct thread`**를 정의하며, 이 구조체는 네 가지 프로젝트 모두에서 수정할 가능성이 높습니다.
* **`palloc.c`, `palloc.h`**: **페이지 할당자**로, 4kB 페이지의 배수로 시스템 메모리를 제공합니다.
* **`malloc.c`, `malloc.h`**: 커널을 위한 **`malloc()` 및 `free()`의 간단한 구현**입니다.
* **`interrupt.c`, `interrupt.h`**: **기본 인터럽트 처리** 및 인터럽트 켜기/끄기 함수입니다.
* **`intr-stubs.S`, `intr-stubs.h`**: **로우 레벨 인터럽트 처리**를 위한 어셈블리 코드입니다.
* **`synch.c`, `synch.h`**: **기본 동기화 기본 요소**: 세마포어, 락, 조건 변수 및 최적화 장벽. 네 가지 프로젝트 모두에서 동기화를 위해 이것들을 사용해야 합니다.
* **`mmu.c`, `mmu.h`**: x86-64 **페이지 테이블 작업**을 위한 함수입니다. Lab1 이후에 이 파일을 더 자세히 살펴볼 것입니다.
* **`io.h`**: **I/O 포트 접근**을 위한 함수입니다. 이 코드는 대부분 `devices` 디렉토리의 소스 코드에서 사용되며, 여러분은 건드릴 필요가 없습니다.
* **`vaddr.h`, `pte.h`**: **가상 주소** 및 **페이지 테이블 항목** 작업을 위한 함수와 매크로입니다. 이들은 프로젝트 3에서 더 중요해질 것입니다. 지금은 무시해도 됩니다.
* **`flags.h`**: x86-64 **`flags` 레지스터**의 몇몇 비트를 정의하는 매크로입니다. 아마도 관심 없을 것입니다.

### `devices` 코드

기본 스레드 커널에는 `devices` 디렉토리의 다음 파일들도 포함됩니다.

* **`timer.c`, `timer.h`**: **시스템 타이머**로, 기본적으로 초당 100번 틱(tick)합니다. **이 프로젝트에서 이 코드를 수정할 것입니다.**
* **`vga.c`, `vga.h`**: VGA 디스플레이 드라이버입니다. 화면에 텍스트를 쓰는 역할을 합니다. 이 코드를 볼 필요는 없을 것입니다. `printf()`가 여러분을 대신하여 VGA 디스플레이 드라이버를 호출하므로, 이 코드를 직접 호출할 이유는 거의 없습니다.
* **`serial.c`, `serial.h`**: **직렬 포트 드라이버**입니다. 역시 `printf()`가 이 코드를 호출하므로 직접 할 필요는 없습니다. 직렬 입력을 입력 레이어(아래 참조)로 전달하여 처리합니다.
* **`block.c`, `block.h`**: **블록 장치**를 위한 추상화 레이어입니다. 즉, 고정 크기 블록 배열로 구성된 랜덤 액세스 디스크와 같은 장치입니다. Pintos는 IDE 디스크와 파티션이라는 두 가지 유형의 블록 장치를 즉시 지원합니다. 블록 장치는 유형에 관계없이 프로젝트 2까지 실제로 사용되지 않을 것입니다.
* **`ide.c`, `ide.h`**: 최대 4개의 IDE 디스크에서 섹터를 읽고 쓰는 것을 지원합니다.
* **`partition.c`, `partition.h`**: 디스크의 파티션 구조를 이해하여 단일 디스크를 독립적인 사용을 위해 여러 영역(파티션)으로 분할할 수 있도록 합니다.
* **`kbd.c`, `kbd.h`**: **키보드 드라이버**입니다. 키 입력을 입력 레이어(아래 참조)로 전달하여 처리합니다.
* **`input.c`, `input.h`**: **입력 레이어**입니다. 키보드 또는 직렬 드라이버에서 전달된 입력 문자를 큐에 넣습니다.
* **`intq.c`, `intq.h`**: **인터럽트 큐**로, 커널 스레드와 인터럽트 핸들러 모두가 접근하려는 원형 큐를 관리합니다. 키보드 및 직렬 드라이버에서 사용됩니다.
* **`rtc.c`, `rtc.h`**: **실시간 클록(Real-time clock) 드라이버**로, 커널이 현재 날짜와 시간을 결정할 수 있도록 합니다. 기본적으로 `thread/init.c`에서 난수 생성기를 위한 초기 시드(seed)를 선택하는 데만 사용됩니다.
* **`speaker.c`, `speaker.h`**: PC 스피커에서 소리를 생성할 수 있는 드라이버입니다.
* **`pit.c`, `pit.h`**: **8254 프로그래머블 인터럽트 타이머(Programmable Interrupt Timer)**를 구성하는 코드입니다. 이 코드는 `devices/timer.c`와 `devices/speaker.c` 모두에서 사용되는데, 각 장치가 PIT의 출력 채널 중 하나를 사용하기 때문입니다.

### `lib` 코드

마지막으로, **`lib`**와 **`lib/kernel`**은 유용한 라이브러리 루틴을 포함합니다. (`lib/user`는 프로젝트 2부터 사용자 프로그램에서 사용되지만, 커널의 일부는 아닙니다.) 몇 가지 세부 사항은 다음과 같습니다.

* **`ctype.h`, `inttypes.h`, `limits.h`, `stdarg.h`, `stdbool.h`, `stddef.h`, `stdint.h`, `stdio.c`, `stdio.h`, `stdlib.c`, `stdlib.h`, `string.c`, `string.h`**: 표준 C 라이브러리의 **부분 집합**입니다.
* **`debug.c`, `debug.h`**: **디버깅을 돕는 함수와 매크로**입니다.
* **`random.c`, `random.h`**: **의사 난수 생성기(Pseudo-random number generator)**입니다. 실제 난수 값 시퀀스는 Pintos 실행마다 동일하게 유지됩니다.
* **`round.h`**: 반올림을 위한 매크로입니다.
* **`syscall-nr.h`**: 시스템 호출 번호입니다. 프로젝트 2까지 사용되지 않습니다.
* **`kernel/list.c`, `kernel/list.h`**: **이중 연결 리스트(Doubly linked list) 구현**입니다. Pintos 코드 전체에서 사용되며, 프로젝트 1에서 여러분도 몇 군데에서 사용하고 싶을 것입니다. **시작하기 전에 이 코드(특히 헤더 파일의 주석)를 훑어보는 것을 권장합니다.**
* **`kernel/bitmap.c`, `kernel/bitmap.h`**: **비트맵 구현**입니다. 원한다면 코드에서 사용할 수 있지만, 프로젝트 1에서는 필요 없을 가능성이 높습니다.
* **`kernel/hash.c`, `kernel/hash.h`**: **해시 테이블 구현**입니다. 프로젝트 3에서 유용하게 사용될 가능성이 높습니다.
* **`kernel/console.c`, `kernel/console.h`, `kernel/stdio.h`**: `printf()` 및 기타 몇 가지 함수를 구현합니다.

---

## 🔒 동기화 (Synchronization)

**적절한 동기화**는 이 문제들에 대한 해답의 중요한 부분입니다. **인터럽트를 끄는 것**으로 모든 동기화 문제를 쉽게 해결할 수 있습니다. 인터럽트가 꺼져 있는 동안에는 동시성(concurrency)이 없으므로, **경쟁 상태(race conditions)의 가능성이 없습니다.** 따라서 모든 동기화 문제를 이 방식으로 해결하고 싶겠지만, **그렇게 하지 마십시오.**

대신, 동기화 문제의 대부분을 해결하기 위해 **세마포어, 락, 조건 변수**를 사용하십시오. 어떤 상황에서 어떤 동기화 기본 요소를 사용해야 할지 확실하지 않다면, 동기화 관련 자료나 `threads/synch.c`의 주석을 읽으십시오.

Pintos 프로젝트에서 **인터럽트 비활성화**로 가장 잘 해결되는 유일한 문제 유형은 **커널 스레드와 인터럽트 핸들러 간에 공유되는 데이터를 조정하는 것**입니다. 인터럽트 핸들러는 **잠들 수 없으므로(cannot sleep)** 락을 획득할 수 없습니다. 이는 커널 스레드와 인터럽트 핸들러 간에 공유되는 데이터가 **커널 스레드 내에서 인터럽트를 끔으로써 보호되어야 함**을 의미합니다.

이 프로젝트는 인터럽트 핸들러에서 **약간의 스레드 상태**에만 접근해야 합니다. **알람 시계**를 위해서는 타이머 인터럽트가 잠자는 스레드를 깨워야 합니다. **고급 스케줄러**에서는 타이머 인터럽트가 일부 전역 및 스레드별 변수에 접근해야 합니다. 커널 스레드에서 이러한 변수에 접근할 때, 타이머 인터럽트가 방해하는 것을 막기 위해 **인터럽트를 비활성화해야 합니다.**

인터럽트를 비활성화할 때는 **가능한 한 최소한의 코드**에 대해서만 그렇게 하도록 주의하십시오. 그렇지 않으면 **타이머 틱이나 입력 이벤트**와 같은 중요한 것을 잃을 수 있습니다. 인터럽트 비활성화는 또한 인터럽트 처리 지연 시간(latency)을 증가시키므로, 너무 과도하게 사용하면 시스템이 느리게 느껴질 수 있습니다.

`synch.c`에 있는 동기화 기본 요소 자체는 인터럽트를 비활성화하여 구현됩니다. 여기서 인터럽트가 비활성화된 상태에서 실행되는 코드의 양을 늘려야 할 수도 있지만, 여전히 최소한으로 유지하도록 노력해야 합니다.

**인터럽트 비활성화**는 코드 섹션이 중단되지 않도록 확인하고 싶을 때 **디버깅에 유용**할 수 있습니다. 프로젝트를 제출하기 전에 **디버깅 코드는 제거**해야 합니다. (단순히 주석 처리만 하지 마십시오. 코드를 읽기 어렵게 만들 수 있습니다.)

제출하는 코드에는 **바쁜 대기(busy waiting)가 없어야 합니다.** **`thread_yield()`를 호출하는 꽉 짜인 루프** 또한 바쁜 대기의 한 형태입니다.

---

## 🛠️ 개발 제안

과거에 많은 그룹이 과제를 여러 부분으로 나눈 다음, 각 팀원이 마감 직전까지 자신의 부분에 작업한 후, 코드를 합치고 제출하기 위해 다시 모였습니다. **이것은 나쁜 아이디어입니다. 이러한 접근 방식은 권장하지 않습니다.** 이렇게 하는 그룹은 종종 두 변경 사항이 서로 충돌하여 마지막 순간에 많은 디버깅이 필요하다는 것을 알게 됩니다. 이렇게 한 일부 그룹은 컴파일조차 되지 않거나 부팅조차 되지 않는 코드를 제출하기도 했습니다.

대신, **`git`**와 같은 **소스 코드 관리 시스템**을 사용하여 팀의 변경 사항을 **일찍, 그리고 자주 통합**하는 것을 권장합니다. 이렇게 하면 모두가 다른 팀원의 코드가 완성되었을 때가 아니라 **작성되는 도중에 볼 수 있으므로** 놀라운 상황이 발생할 가능성이 줄어듭니다. 이러한 시스템은 또한 변경 사항을 검토할 수 있게 하고, 변경 사항이 버그를 유발할 경우 작동하는 버전의 코드로 되돌아갈 수 있도록 합니다.

이 프로젝트와 이후 프로젝트를 작업하는 동안 단순히 이해할 수 없는 버그에 직면할 것으로 예상해야 합니다. 그럴 때, 디버깅 도구에 대한 부록을 다시 읽으십시오. 그 자료에는 다시 작업에 속도를 낼 수 있도록 돕는 유용한 디버깅 팁이 가득합니다. **백트레이스**에 대한 섹션을 반드시 읽으십시오. 모든 커널 패닉이나 어설션 실패로부터 최대한의 정보를 얻는 데 도움이 될 것입니다.

---
